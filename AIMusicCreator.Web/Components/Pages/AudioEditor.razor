@page "/audio-editor"
@using AIMusicCreator.Web.Services
@using AIMusicCreator.Web.Shared
@inject ApiService Api
@inject IJSRuntime JSRuntime
@inject IAudioPlayerService AudioService
@rendermode InteractiveServer

<PageTitle>音频编辑</PageTitle>
<div class="container mt-4">
    <h2>音频编辑</h2>
    <hr />

    <div class="mb-4">
        <label class="form-label">上传音频文件</label>
        <InputFile OnChange="@OnAudioFileSelected" accept="audio/wav,audio/mp3" />
        @* <InputFile @onchange="(e) => OnAudioFileSelected(e)" accept="audio/wav,audio/mp3" /> *@
        <p>状态: @statusMessage</p>
    </div>

    @if (selectedFile != null)
    {
        <div class="row mb-4">
            <div class="col-md-6">
                <h5>原始音频</h5>
                <ErrorBoundary>
                    <AudioPlay_Test SelectedFile="@selectedFile"></AudioPlay_Test>
                    @* <AudioPlayer @ref="originalAudioPlayer" AudioUrl="@originalAudioUrl" ShowDebugInfo="true" FileName="@selectedFile.Name" 
                         /> *@
                    @* OnPlay="HandleAudioPlay"
                        OnPause="HandleAudioPause"
                        OnEnded="HandleAudioEnded" *@
                </ErrorBoundary>
            </div>
            @if (originalAudioPlayer != null)
            {
                <div class="mt-3">
                    <button @onclick="PlayAudio" class="btn btn-primary me-2">播放</button>
                    <button @onclick="PauseAudio" class="btn btn-secondary me-2">暂停</button>
                    <button @onclick="SetHalfVolume" class="btn btn-outline-primary me-2">半音量</button>
                    <button @onclick="JumpToMiddle" class="btn btn-outline-secondary">跳到中间</button>
                </div>
            }
            <div class="col-md-6">
                <h5>处理后音频</h5>
                @if (processedAudioData.Length > 0)
                {
                    <AudioPlay_Test FileContent="@processedAudioData" ContentType="@contentType" localFileName="处理后的视频"></AudioPlay_Test>
                    @* <AudioPlayer @ref="processedAudioPlayer" AudioUrl="@processedAudioUrl" FileName="处理后的音频" /> *@
                    <button @onclick="SaveProcessedAudio" class="btn btn-success mt-2">保存结果</button>
                }
                else
                {
                    <div class="alert alert-info h-100 d-flex align-items-center justify-content-center">
                        处理后的音频将显示在这里
                    </div>
                }
            </div>
        </div>

        <div class="card p-4 mb-4">
            <h5>音频特效</h5>
            <div class="d-flex flex-wrap gap-2">
                <button @onclick='() => AddEffect("echo")' class="btn btn-outline-primary">添加回声</button>
                <button @onclick='() => AddEffect("bass")' class="btn btn-outline-primary">增强低音</button>
                <button @onclick='() => AddEffect("normalize")' class="btn btn-outline-primary">音量标准化</button>
            </div>
        </div>

        <div class="card p-4">
            <h5>多轨混音</h5>
            <div class="mb-3">
                <label class="form-label">添加混音轨道</label>
                <InputFile OnChange="@OnMixTrackAdded" accept="audio/wav" multiple />
            </div>

            @if (mixTracks.Any())
            {
                @foreach (var track in mixTracks.Select((t, i) => new { Track = t, Index = i }))
                {
                    <div class="d-flex align-items-center mb-2">
                        <div class="flex-grow-1">@track.Track.Name</div>
                        <div class="mx-2">音量:</div>
                        <input type="range"
                               @bind="trackVolumes[track.Index]"
                               min="0" max="1" step="0.1"
                               class="w-25" />
                        <button @onclick="() => RemoveTrack(track.Index)" class="btn btn-danger btn-sm ms-2">×</button>
                    </div>
                }
                <button @onclick="MixAudioTracks" class="btn btn-primary mt-2">混音</button>
            }
        </div>
    }
</div>

@code {
    private AudioPlayer? originalAudioPlayer = null;
    // private AudioPlayer? processedAudioPlayer;
    private IBrowserFile? selectedFile;
    private string originalAudioUrl = string.Empty;
    private byte[] originalAudioData = [];
    private string processedAudioUrl = string.Empty;
    private byte[] processedAudioData = [];
    private string? contentType = string.Empty;
    private List<IBrowserFile> mixTracks = new();
    private List<float> trackVolumes = new();
    private bool isProcessing;
    // [Inject] private IJSRuntime JSRuntime { get; set; } = null!;

    private string statusMessage = "等待选择文件...";
    /// <summary>
    /// s添加混音轨道
    /// </summary>
    /// <param name="e"></param>
    private async Task OnMixTrackAdded(InputFileChangeEventArgs e)
    {
        await Task.CompletedTask;
        mixTracks.AddRange(e.FileCount > 0 ? e.GetMultipleFiles() : new List<IBrowserFile>());
        trackVolumes.AddRange(Enumerable.Repeat(0.7f, e.FileCount)); // 默认音量0.7
    }
    private async Task OnAudioFileSelected(InputFileChangeEventArgs e)//InputFileChangeEventArgs
    {
        statusMessage = "事件开始触发...";
        Console.WriteLine("事件触发！文件数量: " + e.FileCount);
        // StateHasChanged();

        await Task.Delay(10); // 让UI有机会更新
        try
        {
            if (e.FileCount == 0)
            {
                statusMessage = "没有选择文件";
                return;
            }
            selectedFile = e.File;

            statusMessage = $"正在处理文件: {selectedFile.Name}";
            // StateHasChanged();
            // 提高文件大小限制以支持大型音频文件
            const long MaxFileSize = 1024 * 1024 * 100; // 100MB
            
            if (selectedFile.Size > MaxFileSize)
            {
                statusMessage = "文件过大，请选择小于100MB的音频文件";
                return;
            }
            
            // 优化的文件读取逻辑，支持分块处理大型音频文件
            using var stream = selectedFile.OpenReadStream(MaxFileSize);
            
            if (selectedFile.Size > MaxFileSize / 2) // 对于较大的文件使用分块处理
            {
                statusMessage = $"正在高效处理大型音频文件: {selectedFile.Name}";
                
                // 使用临时内存流进行分块处理
                using var tempStream = new MemoryStream();
                var buffer = new byte[16384]; // 16KB读取块
                int bytesRead;
                
                while ((bytesRead = await stream.ReadAsync(buffer)) > 0)
                {
                    await tempStream.WriteAsync(buffer.AsMemory(0, bytesRead));
                }
                
                originalAudioData = tempStream.ToArray();
            }
            else
            {
                // 对于小文件，保持原有的一次性读取方式
                originalAudioData = new byte[stream.Length];
                await stream.ReadAsync(originalAudioData, 0, (int)stream.Length);
            }
            // 根据文件类型设置正确的MIME类型
            string mimeType = selectedFile.ContentType;
            if (string.IsNullOrEmpty(mimeType))
            {
                mimeType = selectedFile.Name.ToLower().EndsWith(".wav") ? "audio/wav" : "audio/mpeg";
            }

            statusMessage = $"文件处理完成，大小: {originalAudioData.Length} bytes";
            Console.WriteLine("文件读取完成，大小: " + originalAudioData.Length + " bytes");
            // 转换为Base64 URL（临时方案）
            // originalAudioUrl = $"data:audio/mp3;base64,{Convert.ToBase64String(originalAudioData)}";
            originalAudioUrl = Api.GetAudioUrl(originalAudioData, mimeType);
            // if (originalAudioPlayer != null)
            // {
            //     originalAudioPlayer!.AudioUrl = originalAudioUrl;
            // }

            // 等待组件更新
            await InvokeAsync(StateHasChanged);
            //StateHasChanged(); //通知组件状态已改变
            // 检查音频是否加载成功
            await Task.Delay(500);
            if (originalAudioPlayer != null)
            {
                var duration = await originalAudioPlayer.GetDuration();
                Console.WriteLine($"音频加载完成，时长: {duration}秒");
                Console.WriteLine("原始音频URL: " + originalAudioUrl);
                Console.WriteLine("音频url: " + originalAudioPlayer.AudioUrl);
            }
        }
        catch (Exception ex)
        {
            // 处理异常
            Console.WriteLine($"文件处理错误: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("alert", $"文件上传失败: {ex.Message}");
        }
    }
    private async Task PlayAudio()
    {
        if (originalAudioPlayer != null)
        {
            await originalAudioPlayer.Play();
        }
    }

    private async Task PauseAudio()
    {
        if (originalAudioPlayer != null)
        {
            await originalAudioPlayer.Pause();
        }
    }

    private async Task SetHalfVolume()
    {
        if (originalAudioPlayer != null)
        {
            await originalAudioPlayer.SetVolume(0.5f);
        }
    }

    private async Task JumpToMiddle()
    {
        if (originalAudioPlayer != null)
        {
            var duration = await originalAudioPlayer.GetDuration();
            await originalAudioPlayer.SetCurrentTime(duration / 2);
        }
    }

    private async Task HandleAudioPlay()
    {

        Console.WriteLine("音频开始播放");
        await Task.CompletedTask;
    }

    private async Task HandleAudioPause()
    {
        Console.WriteLine("音频暂停");
        await Task.CompletedTask;
    }

    private async Task HandleAudioEnded()
    {
        Console.WriteLine("音频播放结束");
        await Task.CompletedTask;
    }
    private async Task AddEffect(string effectType)
    {
        if ((selectedFile == null) || isProcessing) return;

        try
        {
            isProcessing = true;
            processedAudioData = await Api.AddAudioEffect(selectedFile, effectType);//y要带上原类型好转换回来，
            contentType = selectedFile.ContentType;
            // processedAudioUrl = Api.GetAudioUrl(processedAudioData);
            await JSRuntime.InvokeVoidAsync("alert", $"特效处理后的数据: {processedAudioData}");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"特效处理失败: {ex.Message}");
        }
        finally
        {
            isProcessing = false;
        }

    }


    private void RemoveTrack(int index)
    {
        mixTracks.RemoveAt(index);
        trackVolumes.RemoveAt(index);
    }

    private async Task MixAudioTracks()
    {
        if (mixTracks.Count < 2)
        {
            await JSRuntime.InvokeVoidAsync("alert", "请至少添加2个轨道进行混音");
            return;
        }

        isProcessing = true;
        try
        {
            (processedAudioData, contentType) = await Api.MixTracks(mixTracks, trackVolumes);
            // contentType = selectedFile.ContentType;
            // processedAudioUrl = Api.GetAudioUrl(processedAudioData);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"混音失败: {ex.Message}");
        }
        finally
        {
            isProcessing = false;
        }
    }

    private async Task SaveProcessedAudio()
    {
        if (processedAudioData != null)
        {
            await Api.SaveFile(processedAudioData, "processed_audio.wav", "audio/wav");
        }
    }
}